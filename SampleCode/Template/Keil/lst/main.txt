; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;320    
;;;321    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;322    {
;;;323    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;324    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;325    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;326    	
;;;327    }
;;;328    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  PDMA_IRQHandler PROC
;;;215    
;;;216    void PDMA_IRQHandler(void)
000000  4916              LDR      r1,|L3.92|
;;;217    {
;;;218        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000002  6808              LDR      r0,[r1,#0]
;;;219    	
;;;220        if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
000004  07c2              LSLS     r2,r0,#31
000006  d002              BEQ      |L3.14|
;;;221        {
;;;222    		#if 1
;;;223            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_GET_ABORT_STS(PDMA));
000008  1d08              ADDS     r0,r1,#4
00000a  6801              LDR      r1,[r0,#0]
00000c  e016              B        |L3.60|
                  |L3.14|
;;;224    		#else
;;;225            if (PDMA_GET_ABORT_STS(PDMA) & (1 << SPI_MASTER_TX_DMA_CH))
;;;226            {
;;;227    
;;;228            }
;;;229            PDMA_CLR_ABORT_FLAG(PDMA, (1 << SPI_MASTER_TX_DMA_CH));
;;;230    
;;;231            if (PDMA_GET_ABORT_STS(PDMA) & (1 << SPI_MASTER_RX_DMA_CH))
;;;232            {
;;;233    
;;;234            }
;;;235            PDMA_CLR_ABORT_FLAG(PDMA, (1 << SPI_MASTER_RX_DMA_CH));
;;;236    		#endif
;;;237        }
;;;238        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
00000e  0782              LSLS     r2,r0,#30
000010  d516              BPL      |L3.64|
;;;239        {
;;;240            if((PDMA_GET_TD_STS(PDMA) & SPI_MASTER_OPENED_CH) == SPI_MASTER_OPENED_CH)
000012  4812              LDR      r0,|L3.92|
000014  3008              ADDS     r0,r0,#8
000016  6801              LDR      r1,[r0,#0]
000018  43c9              MVNS     r1,r1
00001a  0789              LSLS     r1,r1,#30
00001c  d10f              BNE      |L3.62|
;;;241            {
;;;242                /* Clear PDMA transfer done interrupt flag */
;;;243                PDMA_CLR_TD_FLAG(PDMA, SPI_MASTER_OPENED_CH);
00001e  2103              MOVS     r1,#3
000020  6001              STR      r1,[r0,#0]
;;;244    
;;;245    			//insert process
;;;246    			SPI_DISABLE_TX_PDMA(SPI1);
000022  480f              LDR      r0,|L3.96|
000024  68c1              LDR      r1,[r0,#0xc]
000026  f0210101          BIC      r1,r1,#1
00002a  60c1              STR      r1,[r0,#0xc]
;;;247    			SPI_DISABLE_RX_PDMA(SPI1);
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  f0210102          BIC      r1,r1,#2
000032  60c1              STR      r1,[r0,#0xc]
;;;248    			LED_Y ^= 1;
000034  480b              LDR      r0,|L3.100|
000036  6801              LDR      r1,[r0,#0]
000038  f0810101          EOR      r1,r1,#1
                  |L3.60|
00003c  6001              STR      r1,[r0,#0]            ;223
                  |L3.62|
;;;249    			
;;;250    		    #if defined (ENABLE_SPI_NON_AUTO_SS)
;;;251    		    // /CS: de-active
;;;252    			SPI_SET_CS_HIGH;
;;;253    			#endif		
;;;254    
;;;255            }        		
;;;256        }
;;;257        else if (status & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk))     /* Check the DMA time-out interrupt flag */
;;;258        {
;;;259    		LED_G ^= 1;
;;;260            PDMA_CLR_TMOUT_FLAG(PDMA,SPI_MASTER_TX_DMA_CH);
;;;261            PDMA_CLR_TMOUT_FLAG(PDMA,SPI_MASTER_RX_DMA_CH);
;;;262        }
;;;263        else
;;;264        {
;;;265    
;;;266        }
;;;267    
;;;268    	
;;;269    	
;;;270    }
00003e  4770              BX       lr
                  |L3.64|
000040  f4107f40          TST      r0,#0x300             ;257
000044  d0fb              BEQ      |L3.62|
000046  4807              LDR      r0,|L3.100|
000048  1d00              ADDS     r0,r0,#4              ;259
00004a  6802              LDR      r2,[r0,#0]            ;259
00004c  f0820201          EOR      r2,r2,#1              ;259
000050  6002              STR      r2,[r0,#0]            ;259
000052  1580              ASRS     r0,r0,#22             ;260
000054  6008              STR      r0,[r1,#0]            ;260
000056  0040              LSLS     r0,r0,#1              ;261
000058  6008              STR      r0,[r1,#0]            ;261
00005a  4770              BX       lr
;;;271    
                          ENDP

                  |L3.92|
                          DCD      0x4000841c
                  |L3.96|
                          DCD      0x40062000
                  |L3.100|
                          DCD      0x400049c4

                          AREA ||i.SPI_Master_Init||, CODE, READONLY, ALIGN=2

                  SPI_Master_Init PROC
;;;198    */
;;;199    void SPI_Master_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;200    {
;;;201        SPI_Open(SPI1, SPI_MASTER, SPI_MODE_0, 8, SPI_TARGET_FREQ);
000002  4808              LDR      r0,|L4.36|
000004  4c08              LDR      r4,|L4.40|
000006  9000              STR      r0,[sp,#0]
000008  2308              MOVS     r3,#8
00000a  2204              MOVS     r2,#4
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       SPI_Open
;;;202    
;;;203    	#if defined (ENABLE_SPI_NON_AUTO_SS)
;;;204        SYS_UnlockReg();	
;;;205        SYS->GPB_MFPL &= ~( SYS_GPB_MFPL_PB2MFP_Msk);	
;;;206        SYS->GPB_MFPL |=  SYS_GPB_MFPL_PB2MFP_GPIO;	
;;;207    	GPIO_SetMode(PB,BIT2,GPIO_MODE_OUTPUT);	
;;;208        SYS_LockReg();	
;;;209    	#else
;;;210        /* Enable the automatic hardware slave select function. Select the SS pin and configure as low-active. */
;;;211        SPI_EnableAutoSS(SPI1, SPI_SS, SPI_SS_ACTIVE_LOW);
000014  4620              MOV      r0,r4
000016  e8bd4038          POP      {r3-r5,lr}
00001a  2200              MOVS     r2,#0
00001c  2101              MOVS     r1,#1
00001e  f7ffbffe          B.W      SPI_EnableAutoSS
;;;212    	#endif
;;;213    }
;;;214    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x000c3500
                  |L4.40|
                          DCD      0x40062000

                          AREA ||i.SPI_Master_PDMA_Enable||, CODE, READONLY, ALIGN=2

                  SPI_Master_PDMA_Enable PROC
;;;143    
;;;144    void SPI_Master_PDMA_Enable(uint8_t TxRx)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;145    {
;;;146        uint16_t i = 0;
;;;147        static uint16_t j = 0;
;;;148    	
;;;149        // /CS: active
;;;150        #if defined (ENABLE_SPI_NON_AUTO_SS)
;;;151    	SPI_SET_CS_LOW;
;;;152    	#endif
;;;153    	
;;;154    	if (TxRx == SPI_TX)
;;;155    	{
;;;156    		//prepare master TX data
;;;157    		g_au8MasterToSlaveTestPattern[0] = 0xAA;
;;;158    		g_au8MasterToSlaveTestPattern[1] = 0xDD;
;;;159    
;;;160    		j = 1;
;;;161    	    for (i = 2; i < DATA_NUM ; i++)
;;;162    	    {
;;;163    	        g_au8MasterToSlaveTestPattern[i] = (i + 0x10*(j++));
;;;164    	    }
;;;165    		j = 0;
;;;166    	
;;;167    		//TX
;;;168    	    PDMA_SetTransferCnt(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000004  4e2f              LDR      r6,|L5.196|
;;;169    		PDMA_SetTransferAddr(PDMA,SPI_MASTER_TX_DMA_CH, (uint32_t)g_au8MasterToSlaveTestPattern, PDMA_SAR_INC, (uint32_t)&SPI1->TX, PDMA_DAR_FIX);		
;;;170    	    /* Set request source; set basic mode. */
;;;171    	    PDMA_SetTransferMode(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_SPI1_TX, FALSE, 0);
;;;172    	    SPI_TRIGGER_TX_PDMA(SPI1);	
000006  4d30              LDR      r5,|L5.200|
000008  2400              MOVS     r4,#0                 ;145
00000a  b1f0              CBZ      r0,|L5.74|
;;;173    
;;;174        	PDMA_EnableInt(PDMA, SPI_MASTER_TX_DMA_CH, PDMA_INT_TRANS_DONE);			
;;;175    	}
;;;176    	else
;;;177    	{
;;;178    		//RX	
;;;179    		PDMA_SetTransferCnt(PDMA,SPI_MASTER_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
00000c  2308              MOVS     r3,#8
00000e  2200              MOVS     r2,#0
000010  2101              MOVS     r1,#1
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       PDMA_SetTransferCnt
;;;180        	PDMA_SetTransferAddr(PDMA,SPI_MASTER_RX_DMA_CH, (uint32_t)&SPI1->RX, PDMA_SAR_FIX, (uint32_t)g_au8MasterRxBuffer, PDMA_DAR_INC);		
000018  482c              LDR      r0,|L5.204|
00001a  e9cd0400          STRD     r0,r4,[sp,#0]
00001e  4a2a              LDR      r2,|L5.200|
000020  f44f7340          MOV      r3,#0x300
000024  3230              ADDS     r2,r2,#0x30
000026  2101              MOVS     r1,#1
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       PDMA_SetTransferAddr
;;;181    		/* Set request source; set basic mode. */
;;;182    		PDMA_SetTransferMode(PDMA,SPI_MASTER_RX_DMA_CH, PDMA_SPI1_RX, FALSE, 0);
00002e  2300              MOVS     r3,#0
000030  2219              MOVS     r2,#0x19
000032  2101              MOVS     r1,#1
000034  4630              MOV      r0,r6
000036  9400              STR      r4,[sp,#0]
000038  f7fffffe          BL       PDMA_SetTransferMode
;;;183    		SPI_TRIGGER_RX_PDMA(SPI1);
00003c  68e8              LDR      r0,[r5,#0xc]
00003e  f0400002          ORR      r0,r0,#2
000042  60e8              STR      r0,[r5,#0xc]
;;;184    
;;;185        	PDMA_EnableInt(PDMA, SPI_MASTER_RX_DMA_CH, PDMA_INT_TRANS_DONE);			
000044  2200              MOVS     r2,#0
000046  2101              MOVS     r1,#1
000048  e035              B        |L5.182|
                  |L5.74|
00004a  4b20              LDR      r3,|L5.204|
00004c  20aa              MOVS     r0,#0xaa              ;157
00004e  3b08              SUBS     r3,r3,#8              ;157
000050  f1a3020c          SUB      r2,r3,#0xc            ;160
000054  7018              STRB     r0,[r3,#0]            ;157
000056  20dd              MOVS     r0,#0xdd              ;158
000058  7058              STRB     r0,[r3,#1]            ;158
00005a  2001              MOVS     r0,#1                 ;160
00005c  8010              STRH     r0,[r2,#0]            ;160
00005e  2102              MOVS     r1,#2                 ;161
                  |L5.96|
000060  b280              UXTH     r0,r0                 ;163
000062  eb011700          ADD      r7,r1,r0,LSL #4       ;163
000066  545f              STRB     r7,[r3,r1]            ;163
000068  1c40              ADDS     r0,r0,#1              ;163
00006a  1c49              ADDS     r1,r1,#1              ;163
00006c  b289              UXTH     r1,r1                 ;161
00006e  8010              STRH     r0,[r2,#0]            ;163
000070  2908              CMP      r1,#8                 ;161
000072  d3f5              BCC      |L5.96|
000074  8014              STRH     r4,[r2,#0]            ;165
000076  2200              MOVS     r2,#0                 ;168
000078  2308              MOVS     r3,#8                 ;168
00007a  4611              MOV      r1,r2                 ;168
00007c  4630              MOV      r0,r6                 ;168
00007e  f7fffffe          BL       PDMA_SetTransferCnt
000082  4811              LDR      r0,|L5.200|
000084  f44f6140          MOV      r1,#0xc00             ;169
000088  3020              ADDS     r0,r0,#0x20           ;169
00008a  4a10              LDR      r2,|L5.204|
00008c  e9cd0100          STRD     r0,r1,[sp,#0]         ;169
000090  2300              MOVS     r3,#0                 ;169
000092  3a08              SUBS     r2,r2,#8              ;169
000094  4619              MOV      r1,r3                 ;169
000096  4630              MOV      r0,r6                 ;169
000098  f7fffffe          BL       PDMA_SetTransferAddr
00009c  2300              MOVS     r3,#0                 ;171
00009e  2218              MOVS     r2,#0x18              ;171
0000a0  4619              MOV      r1,r3                 ;171
0000a2  4630              MOV      r0,r6                 ;171
0000a4  9400              STR      r4,[sp,#0]            ;171
0000a6  f7fffffe          BL       PDMA_SetTransferMode
0000aa  68e8              LDR      r0,[r5,#0xc]          ;172
0000ac  f0400001          ORR      r0,r0,#1              ;172
0000b0  60e8              STR      r0,[r5,#0xc]          ;172
0000b2  2200              MOVS     r2,#0                 ;174
0000b4  4611              MOV      r1,r2                 ;174
                  |L5.182|
0000b6  b002              ADD      sp,sp,#8
0000b8  4630              MOV      r0,r6
0000ba  e8bd41f0          POP      {r4-r8,lr}
0000be  f7ffbffe          B.W      PDMA_EnableInt
;;;186    	}
;;;187    
;;;188    	
;;;189    }
;;;190    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L5.196|
                          DCD      0x40008000
                  |L5.200|
                          DCD      0x40062000
                  |L5.204|
                          DCD      ||.data||+0x14

                          AREA ||i.SPI_Master_PDMA_PreInit||, CODE, READONLY, ALIGN=2

                  SPI_Master_PDMA_PreInit PROC
;;;94     
;;;95     void SPI_Master_PDMA_PreInit(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;96     {
;;;97         uint16_t i = 0;
;;;98     	
;;;99         // /CS: active
;;;100        #if defined (ENABLE_SPI_NON_AUTO_SS)
;;;101    	SPI_SET_CS_LOW;
;;;102    	#endif
;;;103    	
;;;104    	//prepare data
;;;105        for (i=0; i < DATA_NUM; i++)
;;;106        {
;;;107            g_au8MasterToSlaveTestPattern[i] = i;
000002  4a36              LDR      r2,|L6.220|
000004  2000              MOVS     r0,#0                 ;97
;;;108            g_au8MasterRxBuffer[i] = 0xFF;
000006  21ff              MOVS     r1,#0xff
000008  f1020408          ADD      r4,r2,#8
                  |L6.12|
00000c  5410              STRB     r0,[r2,r0]            ;107
00000e  5421              STRB     r1,[r4,r0]
000010  1c40              ADDS     r0,r0,#1
000012  b280              UXTH     r0,r0                 ;105
000014  2808              CMP      r0,#8                 ;105
000016  d3f9              BCC      |L6.12|
;;;109        }
;;;110    
;;;111        PDMA_Open(PDMA, SPI_MASTER_OPENED_CH);
000018  4d31              LDR      r5,|L6.224|
00001a  2103              MOVS     r1,#3
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       PDMA_Open
;;;112    
;;;113    	//TX
;;;114        PDMA_SetTransferCnt(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000022  2200              MOVS     r2,#0
000024  2308              MOVS     r3,#8
000026  4611              MOV      r1,r2
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       PDMA_SetTransferCnt
;;;115        /* Set source/destination address and attributes */
;;;116        PDMA_SetTransferAddr(PDMA,SPI_MASTER_TX_DMA_CH, (uint32_t)g_au8MasterToSlaveTestPattern, PDMA_SAR_INC, (uint32_t)&SPI1->TX, PDMA_DAR_FIX);
00002e  f44f6140          MOV      r1,#0xc00
000032  482c              LDR      r0,|L6.228|
000034  e9cd0100          STRD     r0,r1,[sp,#0]
000038  2300              MOVS     r3,#0
00003a  4a28              LDR      r2,|L6.220|
00003c  4619              MOV      r1,r3
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       PDMA_SetTransferAddr
;;;117        /* Set request source; set basic mode. */
;;;118        PDMA_SetTransferMode(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_SPI1_TX, FALSE, 0);
000044  2600              MOVS     r6,#0
000046  4633              MOV      r3,r6
000048  2218              MOVS     r2,#0x18
00004a  4631              MOV      r1,r6
00004c  4628              MOV      r0,r5
00004e  9600              STR      r6,[sp,#0]
000050  f7fffffe          BL       PDMA_SetTransferMode
;;;119        /* Single request type. SPI only support PDMA single request type. */
;;;120        PDMA_SetBurstType(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_REQ_SINGLE, 0);
000054  2300              MOVS     r3,#0
000056  2204              MOVS     r2,#4
000058  4619              MOV      r1,r3
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       PDMA_SetBurstType
;;;121        /* Disable table interrupt */
;;;122        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
000060  6828              LDR      r0,[r5,#0]
000062  f0400080          ORR      r0,r0,#0x80
000066  6028              STR      r0,[r5,#0]
;;;123    
;;;124    	//RX	
;;;125        PDMA_SetTransferCnt(PDMA,SPI_MASTER_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000068  2308              MOVS     r3,#8
00006a  2200              MOVS     r2,#0
00006c  2101              MOVS     r1,#1
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       PDMA_SetTransferCnt
;;;126        /* Set source/destination address and attributes */
;;;127        PDMA_SetTransferAddr(PDMA,SPI_MASTER_RX_DMA_CH, (uint32_t)&SPI1->RX, PDMA_SAR_FIX, (uint32_t)g_au8MasterRxBuffer, PDMA_DAR_INC);
000074  4a1b              LDR      r2,|L6.228|
000076  e9cd4600          STRD     r4,r6,[sp,#0]
00007a  f44f7340          MOV      r3,#0x300
00007e  3210              ADDS     r2,r2,#0x10
000080  2101              MOVS     r1,#1
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       PDMA_SetTransferAddr
;;;128        /* Set request source; set basic mode. */
;;;129        PDMA_SetTransferMode(PDMA,SPI_MASTER_RX_DMA_CH, PDMA_SPI1_RX, FALSE, 0);
000088  2300              MOVS     r3,#0
00008a  2219              MOVS     r2,#0x19
00008c  2101              MOVS     r1,#1
00008e  4628              MOV      r0,r5
000090  9600              STR      r6,[sp,#0]
000092  f7fffffe          BL       PDMA_SetTransferMode
;;;130        /* Single request type. SPI only support PDMA single request type. */
;;;131        PDMA_SetBurstType(PDMA,SPI_MASTER_RX_DMA_CH, PDMA_REQ_SINGLE, 0);
000096  2300              MOVS     r3,#0
000098  2204              MOVS     r2,#4
00009a  2101              MOVS     r1,#1
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       PDMA_SetBurstType
;;;132        /* Disable table interrupt */
;;;133        PDMA->DSCT[SPI_MASTER_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
0000a2  6928              LDR      r0,[r5,#0x10]
0000a4  f0400080          ORR      r0,r0,#0x80
0000a8  6128              STR      r0,[r5,#0x10]
;;;134    
;;;135        SPI_TRIGGER_RX_PDMA(SPI1);
0000aa  480e              LDR      r0,|L6.228|
0000ac  3820              SUBS     r0,r0,#0x20
0000ae  68c1              LDR      r1,[r0,#0xc]
0000b0  f0410102          ORR      r1,r1,#2
0000b4  60c1              STR      r1,[r0,#0xc]
;;;136        SPI_TRIGGER_TX_PDMA(SPI1);
0000b6  68c1              LDR      r1,[r0,#0xc]
0000b8  f0410101          ORR      r1,r1,#1
0000bc  60c1              STR      r1,[r0,#0xc]
;;;137    
;;;138        PDMA_EnableInt(PDMA, SPI_MASTER_TX_DMA_CH, PDMA_INT_TRANS_DONE);
0000be  2200              MOVS     r2,#0
0000c0  4611              MOV      r1,r2
0000c2  4628              MOV      r0,r5
0000c4  f7fffffe          BL       PDMA_EnableInt
;;;139        PDMA_EnableInt(PDMA, SPI_MASTER_RX_DMA_CH, PDMA_INT_TRANS_DONE);
0000c8  2200              MOVS     r2,#0
0000ca  2101              MOVS     r1,#1
0000cc  4628              MOV      r0,r5
0000ce  f7fffffe          BL       PDMA_EnableInt
;;;140        NVIC_EnableIRQ(PDMA_IRQn);
0000d2  e8bd407c          POP      {r2-r6,lr}
0000d6  2028              MOVS     r0,#0x28
0000d8  f7ffbffe          B.W      NVIC_EnableIRQ
;;;141    	
;;;142    }
;;;143    
                          ENDP

                  |L6.220|
                          DCD      ||.data||+0xc
                  |L6.224|
                          DCD      0x40008000
                  |L6.228|
                          DCD      0x40062020

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;328    
;;;329    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L7.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L7.10|
;;;330    {
;;;331        /*---------------------------------------------------------------------------------------------------------*/
;;;332        /* Init System Clock                                                                                       */
;;;333        /*---------------------------------------------------------------------------------------------------------*/
;;;334        /* Unlock protected registers */
;;;335        SYS_UnlockReg();
;;;336    
;;;337        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;338        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2540          MOV      r5,#0x40004000
000022  f8d50140          LDR      r0,[r5,#0x140]
000026  f02000f0          BIC      r0,r0,#0xf0
00002a  f8c50140          STR      r0,[r5,#0x140]
;;;339    
;;;340        /* Enable External XTAL (4~24 MHz) */
;;;341        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;342    
;;;343        /* Waiting for 12MHz clock ready */
;;;344        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       CLK_WaitClockReady
;;;345    
;;;346        /* Set core clock as PLL_CLOCK from PLL */
;;;347        CLK_SetCoreClock(FREQ_192MHZ);
00003a  481e              LDR      r0,|L7.180|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;348        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;349        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;350    
;;;351        /* Enable UART clock */
;;;352        CLK_EnableModuleClock(UART0_MODULE);
000046  4e1c              LDR      r6,|L7.184|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;353    
;;;354        /* Select UART clock source from HXT */
;;;355        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       CLK_SetModuleClock
;;;356    
;;;357        CLK_SetModuleClock(SPI1_MODULE, CLK_CLKSEL2_SPI1SEL_PCLK0, MODULE_NoMsk);
000058  4e18              LDR      r6,|L7.188|
00005a  2200              MOVS     r2,#0
00005c  2180              MOVS     r1,#0x80
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       CLK_SetModuleClock
;;;358        CLK_EnableModuleClock(SPI1_MODULE);
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       CLK_EnableModuleClock
;;;359    
;;;360        CLK_EnableModuleClock(PDMA_MODULE);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       CLK_EnableModuleClock
;;;361    
;;;362    //	TIMER0_HW_Init();
;;;363    	TIMER1_HW_Init();
000070  f7fffffe          BL       TIMER1_HW_Init
;;;364    	
;;;365        /* Update System Core Clock */
;;;366        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;367        SystemCoreClockUpdate();
000074  f7fffffe          BL       SystemCoreClockUpdate
;;;368    
;;;369        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;370        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000078  6be0              LDR      r0,[r4,#0x3c]
00007a  f420007f          BIC      r0,r0,#0xff0000
00007e  63e0              STR      r0,[r4,#0x3c]
;;;371        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000080  6be0              LDR      r0,[r4,#0x3c]
000082  f44000cc          ORR      r0,r0,#0x660000
000086  63e0              STR      r0,[r4,#0x3c]
;;;372    
;;;373        /* Setup SPI1 multi-function pins */
;;;374        SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB4MFP_Msk | SYS_GPB_MFPL_PB5MFP_Msk| SYS_GPB_MFPL_PB3MFP_Msk| SYS_GPB_MFPL_PB2MFP_Msk);	
000088  6ba0              LDR      r0,[r4,#0x38]
00008a  490d              LDR      r1,|L7.192|
00008c  4008              ANDS     r0,r0,r1
00008e  63a0              STR      r0,[r4,#0x38]
;;;375        SYS->GPB_MFPL |= SYS_GPB_MFPL_PB4MFP_SPI1_MOSI | SYS_GPB_MFPL_PB5MFP_SPI1_MISO | SYS_GPB_MFPL_PB3MFP_SPI1_CLK | SYS_GPB_MFPL_PB2MFP_SPI1_SS;
000090  6ba0              LDR      r0,[r4,#0x38]
000092  490c              LDR      r1,|L7.196|
000094  4308              ORRS     r0,r0,r1
000096  63a0              STR      r0,[r4,#0x38]
;;;376    
;;;377        /* Enable SPI1 clock pin (PB3) schmitt trigger */
;;;378        PB->SMTEN |= GPIO_SMTEN_SMTEN3_Msk;
000098  6e68              LDR      r0,[r5,#0x64]
00009a  f0400008          ORR      r0,r0,#8
00009e  6668              STR      r0,[r5,#0x64]
;;;379    
;;;380        /* Enable SPI1 I/O high slew rate */
;;;381        GPIO_SetSlewCtl(PB, 0xF, GPIO_SLEWCTL_HIGH);
0000a0  2201              MOVS     r2,#1
0000a2  210f              MOVS     r1,#0xf
0000a4  4808              LDR      r0,|L7.200|
0000a6  f7fffffe          BL       GPIO_SetSlewCtl
0000aa  2000              MOVS     r0,#0
0000ac  f8c40100          STR      r0,[r4,#0x100]
;;;382    	
;;;383        /* Lock protected registers */
;;;384        SYS_LockReg();
;;;385    }
0000b0  bd70              POP      {r4-r6,pc}
;;;386    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L7.180|
                          DCD      0x0b71b000
                  |L7.184|
                          DCD      0x57803d10
                  |L7.188|
                          DCD      0x6660000e
                  |L7.192|
                          DCD      0xff0000ff
                  |L7.196|
                          DCD      0x00555500
                  |L7.200|
                          DCD      0x40004040

                          AREA ||i.TIMER0_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_HW_Init PROC
;;;309    
;;;310    void TIMER0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;311    {
;;;312    	CLK_EnableModuleClock(TMR0_MODULE);
000002  4c06              LDR      r4,|L8.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;313    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f7100          MOV      r1,#0x200
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;314    }
;;;315    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;315    
;;;316    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;317    {
;;;318    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L9.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;319    }
;;;320    
                          ENDP

                  |L9.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_HW_Init PROC
;;;295    
;;;296    void TIMER1_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;297    {
;;;298        CLK_EnableModuleClock(TMR1_MODULE);
000002  4c06              LDR      r4,|L10.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;299        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f41e0          MOV      r1,#0x7000
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;300    }
;;;301    
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;301    
;;;302    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;303    {
;;;304        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L11.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;305        TIMER_EnableInt(TIMER1);
;;;306        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;307        TIMER_Start(TIMER1);
;;;308    }
000028  bd10              POP      {r4,pc}
;;;309    
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;271    
;;;272    void TMR1_IRQHandler(void)
000000  4812              LDR      r0,|L12.76|
;;;273    {
000002  b500              PUSH     {lr}
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
00000a  2900              CMP      r1,#0
00000c  d01c              BEQ      |L12.72|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;274    	static uint16_t CNT = 0;	
;;;275    	static uint32_t log = 0;	
;;;276    	
;;;277        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;278        {
;;;279            TIMER_ClearIntFlag(TIMER1);
;;;280    		tick_counter();
000012  f7fffffe          BL       tick_counter
000016  4a0e              LDR      r2,|L12.80|
;;;281    
;;;282    		if ((get_tick() % 50) == 0)
000018  2132              MOVS     r1,#0x32
00001a  6890              LDR      r0,[r2,#8]  ; conter_tick
00001c  fbb0f3f1          UDIV     r3,r0,r1
000020  fb010013          MLS      r0,r1,r3,r0
000024  b918              CBNZ     r0,|L12.46|
;;;283    		{
;;;284    			set_flag(flag_SPI_Transmit_timing , ENABLE);
000026  6850              LDR      r0,[r2,#4]  ; BitFlag
000028  f0400002          ORR      r0,r0,#2
00002c  6050              STR      r0,[r2,#4]  ; BitFlag
                  |L12.46|
;;;285    		}
;;;286    	
;;;287    		if (CNT++ > 1000)
00002e  8850              LDRH     r0,[r2,#2]  ; CNT
000030  1c41              ADDS     r1,r0,#1
000032  8051              STRH     r1,[r2,#2]
000034  f5b07f7a          CMP      r0,#0x3e8
000038  d906              BLS      |L12.72|
;;;288    		{		
;;;289    			CNT = 0;
00003a  2000              MOVS     r0,#0
00003c  8050              STRH     r0,[r2,#2]
;;;290    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;291    			LED_R ^= 1;
00003e  4805              LDR      r0,|L12.84|
000040  6801              LDR      r1,[r0,#0]
000042  f0810101          EOR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
                  |L12.72|
;;;292    		}
;;;293        }
;;;294    }
000048  bd00              POP      {pc}
;;;295    
                          ENDP

00004a  0000              DCW      0x0000
                  |L12.76|
                          DCD      0x40050100
                  |L12.80|
                          DCD      ||.data||
                  |L12.84|
                          DCD      0x400049c0

                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;62     
;;;63     void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;64     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;65         uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;66         
;;;67         printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L13.56|
00000a  f7fffffe          BL       __2printf
;;;68         for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L13.42|
                  |L13.16|
;;;69         {
;;;70             printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L13.76|
000014  f7fffffe          BL       __2printf
;;;71             if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L13.38|
;;;72             {
;;;73                 printf("\r\n");
000020  a00c              ADR      r0,|L13.84|
000022  f7fffffe          BL       __2printf
                  |L13.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;68
                  |L13.42|
00002a  42ac              CMP      r4,r5                 ;68
00002c  dbf0              BLT      |L13.16|
;;;74             }            
;;;75         }
;;;76         printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L13.88|
000034  f7ffbffe          B.W      __2printf
;;;77     }
;;;78     
                          ENDP

                  |L13.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L13.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L13.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L13.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;84     
;;;85     uint32_t get_tick(void)
000000  4801              LDR      r0,|L14.8|
;;;86     {
;;;87     	return (conter_tick);
000002  6880              LDR      r0,[r0,#8]  ; conter_tick
;;;88     }
000004  4770              BX       lr
;;;89     
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  main PROC
;;;394    
;;;395    int main()
000000  f7fffffe          BL       SYS_Init
;;;396    {
;;;397    	
;;;398        SYS_Init();
;;;399        /* Init UART to 115200-8n1 for print message */
;;;400        UART_Open(UART0, 115200);
000004  f44f31e1          MOV      r1,#0x1c200
000008  481b              LDR      r0,|L15.120|
00000a  f7fffffe          BL       UART_Open
;;;401    
;;;402    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00000e  f7fffffe          BL       CLK_GetCPUFreq
000012  4601              MOV      r1,r0
000014  a019              ADR      r0,|L15.124|
000016  f7fffffe          BL       __2printf
;;;403    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001a  f7fffffe          BL       CLK_GetHXTFreq
00001e  4601              MOV      r1,r0
000020  a01d              ADR      r0,|L15.152|
000022  f7fffffe          BL       __2printf
;;;404    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000026  f7fffffe          BL       CLK_GetLXTFreq
00002a  4601              MOV      r1,r0
00002c  a020              ADR      r0,|L15.176|
00002e  f7fffffe          BL       __2printf
;;;405    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000032  f7fffffe          BL       CLK_GetPCLK0Freq
000036  4601              MOV      r1,r0
000038  a023              ADR      r0,|L15.200|
00003a  f7fffffe          BL       __2printf
;;;406    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
00003e  f7fffffe          BL       CLK_GetPCLK1Freq
000042  4601              MOV      r1,r0
000044  a027              ADR      r0,|L15.228|
000046  f7fffffe          BL       __2printf
;;;407    
;;;408    	SPI_Master_Init();
00004a  f7fffffe          BL       SPI_Master_Init
;;;409    	SPI_Master_PDMA_PreInit();
00004e  f7fffffe          BL       SPI_Master_PDMA_PreInit
;;;410    
;;;411    	LED_Init();
000052  f7fffffe          BL       LED_Init
;;;412    	TIMER1_Init();
000056  f7fffffe          BL       TIMER1_Init
;;;413    	
;;;414        /* Got no where to go, just loop forever */
;;;415        while(1)
;;;416        {
;;;417    //		TIMER0_Polling(100);
;;;418    
;;;419    		if (is_flag_set(flag_SPI_Transmit_timing))	
00005a  4c29              LDR      r4,|L15.256|
                  |L15.92|
00005c  6860              LDR      r0,[r4,#4]  ; BitFlag
00005e  0780              LSLS     r0,r0,#30
000060  d5fc              BPL      |L15.92|
;;;420    		{
;;;421    			set_flag(flag_SPI_Transmit_timing , DISABLE);
000062  6860              LDR      r0,[r4,#4]  ; BitFlag
000064  f0200002          BIC      r0,r0,#2
000068  6060              STR      r0,[r4,#4]  ; BitFlag
;;;422    			SPI_Master_PDMA_Enable(SPI_RX);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       SPI_Master_PDMA_Enable
;;;423    			SPI_Master_PDMA_Enable(SPI_TX);
000070  2000              MOVS     r0,#0
000072  f7fffffe          BL       SPI_Master_PDMA_Enable
000076  e7f1              B        |L15.92|
;;;424    		}
;;;425    
;;;426        }
;;;427    
;;;428    }
;;;429    
                          ENDP

                  |L15.120|
                          DCD      0x40070000
                  |L15.124|
00007c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000080  4b5f4765
000084  74435055
000088  46726571
00008c  203a2025
000090  38640d0a
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L15.152|
000098  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
00009c  47657448
0000a0  58544672
0000a4  6571203a
0000a8  20253864
0000ac  0d0a00  
0000af  00                DCB      0
                  |L15.176|
0000b0  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000b4  4765744c
0000b8  58544672
0000bc  6571203a
0000c0  20253864
0000c4  0d0a00  
0000c7  00                DCB      0
                  |L15.200|
0000c8  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000cc  47657450
0000d0  434c4b30
0000d4  46726571
0000d8  203a2025
0000dc  38640d0a
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L15.228|
0000e4  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000e8  47657450
0000ec  434c4b31
0000f0  46726571
0000f4  203a2025
0000f8  38640d0a
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L15.256|
                          DCD      ||.data||

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;89     
;;;90     void set_tick(uint32_t t)
000000  4901              LDR      r1,|L16.8|
;;;91     {
;;;92     	conter_tick = t;
000002  6088              STR      r0,[r1,#8]  ; conter_tick
;;;93     }
000004  4770              BX       lr
;;;94     
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      ||.data||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;79     
;;;80     void tick_counter(void)
000000  4802              LDR      r0,|L17.12|
;;;81     {
;;;82     	conter_tick++;
000002  6881              LDR      r1,[r0,#8]  ; conter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6081              STR      r1,[r0,#8]  ; conter_tick
;;;83     }
000008  4770              BX       lr
;;;84     
                          ENDP

00000a  0000              DCW      0x0000
                  |L17.12|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  j
000000  0000              DCW      0x0000
                  ||CNT||
000002  0000              DCW      0x0000
                  BitFlag
                          DCD      0x00000000
                  conter_tick
                          DCD      0x00000000
                  g_au8MasterToSlaveTestPattern
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                  g_au8MasterRxBuffer
000014  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000

                          AREA ||area_number.21||, DATA, ALIGN=0

                          EXPORTAS ||area_number.21||, ||.data||
                  g_au8SlaveToMasterTestPattern
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCDU     0x00000000

                          AREA ||area_number.22||, DATA, ALIGN=0

                          EXPORTAS ||area_number.22||, ||.data||
                  g_au8SlaveRxBuffer
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCDU     0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_468c6c6b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____REVSH|
#line 402
|__asm___6_main_c_468c6c6b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____RRX|
#line 587
|__asm___6_main_c_468c6c6b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
